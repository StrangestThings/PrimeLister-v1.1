# PrimeLister v2.6 ðŸš€

**A high-performance, multi-threaded prime number generator in C++.**
*From Excel trendlines to 52 million primes/second.*

## ðŸ“– Overview
PrimeLister is a highly optimized implementation of a **Segmented Sieve of Eratosthenes** using **Wheel Factorization (Mod 6)**. Unlike standard implementations that sieve natural numbers, PrimeLister operates entirely in a compressed **index space**, reducing memory usage by ~66% and replacing costly division/modulus operations with pre-calculated polynomial steps.

**Performance:**
- **Speed:** ~52 Million primes/s (on Intel i7-9750H).
- **Efficiency:** Uses bit-twiddling (64 candidates processed per instruction).
- **Parallelism:** OpenMP dynamic scheduling.



## ðŸ’¡ The Core Idea: "Single Array" Index Sieving

The algorithm is based on the observation that all primes $p \ge 5$ exist in the form $6k \pm 1$. We can map these candidates to a single linear index $i$:

| Index $i$ | Formula | Candidate Value | Type |
| :--- | :--- | :--- | :--- |
| **Even** (0, 2, 4...) | $3i + 5$ | $5, 11, 17, 23...$ | ($6k - 1$) |
| **Odd** (1, 3, 5...) | $3i + 4$ | $7, 13, 19, 25...$ | ($6k + 1$) |

Instead of sieving numbers, we sieve these **indices**. If an index remains "marked" (or unmarked, depending on logic), the corresponding number is prime.

### ðŸ“‰ The "Excel" Derivation
The formulas for eliminating non-primes were not just derived algebraically, but originally **discovered by pattern analysis** (plotting the indices of composite numbers in Excel and fitting polynomial trendlines).

This led to three distinct "Phases" of elimination, which allow the program to jump directly to composite numbers without checking divisibility.

#### Phase 1: The "Type A" Sweeps (Derived from $6k-1$)
Eliminates multiples of primes generated by even indices.
- **Start Index:** $7i + 10$
- **Step Size:** $6i + 10$
- *Logic:* Corresponds to composites formed by $(6k-1) \times (6m+1)$.

#### Phase 2: The "Type B" Sweeps (Derived from $6k+1$)
Eliminates multiples of primes generated by odd indices.
- **Start Index:** $3i^2 + 8i + 4$
- **Step Size:** $6i + 8$
- *Logic:* Corresponds to squares/multiples of $(6k+1)$.

#### Phase 3: The Cross-Squares
Cleaning up remaining squares of Type A primes.
- **Start Index:** $3i^2 + 10i + 7$
- **Step Size:** $6i + 10$


## ðŸ›  Features & Optimizations

### 1. Segmented Sieving (L1/L2 Cache Optimization)
The number range is split into small chunks (segments) that fit entirely into the CPU's L1/L2 cache. This prevents "cache trashing" when processing billions of numbers.

### 2. No Modulo Operators (`%`)
By using the formulas above, the inner loop involves **only addition**.


// Example inner loop (Phase 1)
for (u64 j = start; j < end; j += step) {
    setbit(j - base);
}



### 3. Bit-Packed Storage

We use a `vector<uint64_t>` as a custom bitset.

* **Memory:** 1 bit represents 1 potential prime (after wheel factorization).
* **Scanning:** We use `ctz` (Count Trailing Zeros) hardware instructions to identify primes in blocks of 64 at once, rather than checking one by one.

### 4. OpenMP Multithreading

The segments are distributed across all available CPU cores using `dynamic` scheduling to handle load balancing.



## ðŸš€ Build & Run

### Windows (Visual Studio / MSVC)

Open the "Native Tools Command Prompt" and run:


cl /O2 /openmp /EHsc Version2.6.cpp /Fe:PrimeLister.exe



### Linux (GCC)


g++ -O3 -fopenmp Version2.6.cpp -o PrimeLister



### Usage

Run the executable. You will be asked for:

1. **Upper Limit N:** The number up to which you want to find primes (e.g., `1000000000`).
2. **Columns:** Format for the output file `PrimeList.txt`.

---

## ðŸ“œ Credits & History

* **Concept:** Pattern discovery via ImageJ & Excel macros.
* **Version 1.0:** ImageJ Macro implementation.
* **Version 2.6 (C++):** Fully optimized C++ implementation with OpenMP and bit-level optimizations.

*Based on the "Single Array" logic: combining 6k-1 and 6k+1 candidates into one unified memory space to avoid sorting overhead.*
